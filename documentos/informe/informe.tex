\documentclass[a4paper,10pt]{article}
% Paquete para la inclusion de graficos.
\usepackage{graphicx}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
% Paqiete para la inclusion de PDFs.
\usepackage{pdfpages}
\usepackage{listings}
\graphicspath{ {src/images/} }

\title{
	\textbf{Trabajo Práctico Nº 1: Conjunto de instrucciones MIPS}
}

\author{
	Sebastian Ripari, \textit{Padrón Nro. 96.453}\\
	\texttt{sebastiandanielripari@hotmail.com}\\[2.5ex]
	Cesar Emanuel Lencina, \textit{Padrón Nro. 96.078}\\
	\texttt{cesar\char`_1990@live.com}\\[2.5ex]
	Pablo Sivori, \textit{Padrón Nro. 84.026}\\
	\texttt{sivori.daniel@gmail.com}\\[2.5ex]
	\normalsize{2do. Cuatrimestre de 2017}\\
	\normalsize{66.20 Organización de Computadoras  $-$ Práctica Jueves}\\
	\normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}\\
}

\date{}

\begin{document}

\maketitle
\thispagestyle{empty}   % quita el número en la primer página

\begin{abstract}
Se implemento un programa que realiza el calculo del maximo comun divisor y del minimo comun multiplo,
mediante el uso del Algoritmo de Euclides. Para la implementacion del algortimo, se utilizo el lenguaje C, y con la particularidad de las funciones matematicas fueron llevadas a cabo usando Assembler de MIPS. Por ende la compilacion del programa, comprende el linkeo de estas funciones en Assembler.
\end{abstract}

\null\newpage

\tableofcontents

\null\newpage


\section{Introducción}
El \textit{algoritmo de Euclides} es un método antiguo y eficaz para calcular el máximo común divisor (MCD). Fue originalmente descrito por Euclides en su obra Elementos. El \textit{algoritmo de Euclides extendido} es una ligera modificacion que permite ademas expresar al maximo comun divisor como una combinacion lineal.

\section{Desarrollo}
\subsection{Consideraciones:}

\begin{enumerate}
\item Antes de realizar la codificación de las funciones MCD y MCM en código MIPS 32 se hizo un gráfico del stack frame de ambas, teniendo en cuenta que la función MCD se la dibujo sin ABA y sin el registro ra (return address), y lo contrario con la función MCM la cual invoca a la anterior, resultando ser una función no hoja. Siguiendo los lineamientos del stack frame (SF) se crean 4 áreas en el SF de cada función (SRA, FRA, LTA y ABA).
\item Cada area del stack frame debe tener su padding si lo necesita, para que sean múltiplos de 8 bytes.

\item Con el stack de ambas funciones comenzamos pasar el código de C a lenguaje MIPS 32, respetando la convención de la ABI.

\item En el código MIPS 32 utilizamos el include mips/regdef.h para utilizar las constantes sp, fp, t1, …, etc y de esta manera no tener que utilizar los números de registros \verb|($0,$1,....,$32)|.

\item Se utiliza la directiva .globl mcd y .globl mcm para que ambas funciones puedan ser llamadas desde otro archivo.

\item Se crean constantes para definir el tamaño del stack frame de las funciones así como también la posición de los registros fp, sp y ra. De esta manera si hay algún cambio en la posición donde se encuentran en el stack, solo modificamos el valor de la constante.

\item Ponemos el align 2 para que las instrucciones estén alineadas 4 bytes. De esta manera el program counter avanzará de a 4 bytes.

\item Para facilitar el paso anterior, se creo una carpeta compartida al netbsd, la cual contenia los archivos con el código fuente a ejecutar. Para esto montamos la carpepeta una vez realizado el tunel. Para esto ejecutamos el comando:\newline
sshfs -p 2222 -C root@127.0.0.1:/root/tp1/\newline/home/username/workspace/orga6620\_mounted/.\newline De esta manera podemos editar los archivos directamente y luego compilarlos en netbsd sin tener la necesidad de hacer una transferencia (copy) de los archivos modificados a esta carpeta.

\end{enumerate}

\subsection{Proceso de compilación:}

Para compilar el programa utilizamos el siguiente Makefile:\newline

\# Build version\newline
VERSION = 0\newline

\# Compiler and env set up\newline
CC=gcc\newline
CFLAGS  = -Wall -O0 \newline
OBJ = common.o commonfunc.o\newline

\# Rules\newline
default: clean bin\newline

bin: 
\$(CC) \$(CFLAGS) -o common common.c commonfunc.c mathfunc.S -D\_VERSION\_=\"\$(VERSION)\"\newline

clean:
\$(RM) common\newline

En CFLAGS ponemos -O0 para apagar las optimizaciones.\newline

Desde la terminal nos posicionamos en la carpeta tp1\_orga6620 y corremos el comando make. De esta manera ira a la regla default ejecutando el clean y luego el bin para generar el archivo common (nombre del programa ejecutable). Esto se corre en netbsd para generar el ejecutable que incluya el código MIPS 32 de las funciones, el cual se encuentra en el archivo mathfunc.S.

\null\newpage

\section{Casos de prueba:}

Ejecutamos desde la carpeta tp1\_orga6620/pruebas/ el script pruebas.sh, en netbsd con gxemul, con el siguiente comando bash pruebas.sh. De esta manera obtenemos el siguiente resultado:\newline

root@:\textasciitilde/tp1/tp1\_orga6620/Pruebas\# bash pruebas.sh|

\subsection{Comienzo de pruebas:}
\subsubsection{Test 1}
Mostramos el mensaje de ayuda usando la opcion -h.\newline \newline
Usage:\newline
\verb|        common -h|\newline
\verb|        common -V|\newline
\verb|        common [options] M N|\newline
\verb|Options:|\newline
\verb|        -h,             --help          Prints usage information.|\newline
\verb|        -V,             --version       Prints version information.|\newline
\verb|        -o,             --output        Path to output file.|\newline
\verb|        -d              --divisor       Just the divisor|\newline
\verb|        -m              --multiple      Just the multiple|\newline
\verb|Examples:|
\verb|        common -o - 256 19|


\subsubsection{Test 2}
Mostramos la versión del common usando la opción -V. \newline
 Common version 1.0 \newline

\subsubsection{Test 3}
Mostramos por stdout el máximo común divisor entre 5 y 10.\newline
5

\subsubsection{Test 4}
Mostramos por stdout el minimo común múltiplo entre 5 y 10.\newline
10

\subsubsection{Test 5}
Mostramos por stdout el mcm y el mcd entre 5 y 10.\newline
5\newline
10

\subsubsection{Test 6}
Mostramos por stdout el mcd entre 256 y 192.\newline
64

\subsubsection{Test 7}
Mostramos por stdout el mcm entre 256 y 192.\newline
768

\subsubsection{Test 8}
Mostramos por stdout el mcd y el mcm entre 256 y 192.\newline
64\newline
768\newline

\subsubsection{Test 9}
Mostramos por stdout el mcd entre 1111 y 1294.\newline
1

\subsubsection{Test 10}
Mostramos por stdout el mcm entre 1111 y 1294.\newline
1437634

\subsubsection{Test 11}
Mostramos por stdout el mcd y el mcm entre 1111 y 1294.\newline
1\newline
1437634

\subsubsection{Test 12}
Ingresamos un comando invalido (./common -i 5 10).

\subsubsection{Test 13}
Ingresamos un argumento extra en la opción -h (./common -h 10).

\subsubsection{Test 14}
Ingresamos un comando invalido (./common aaa bbb ccc ).

\subsubsection{Test 15}
No pasamos ningún parámetro (./common).

\subsubsection{Test 16}
No pasamos el parámetro número en la opción -d (./common -d).

\subsubsection{Test 17}
Pasamos letras en lugar del número (./common -d -o - sss).

\null\newpage

\section{Partes del codigo relevantes}

\subsection{MCD}

\#guardo en la aba de la funcion que me llamo los argumentos
sw		a0, SF\_MCM\_A0\_POS(\$fp)\newline
sw		a1, SF\_MCM\_A1\_POS(\$fp)\newline

Esto es para respetar la convención de la ABI, dado que la función llamada deberá preservar los valores de la función llamante.

\subsection{MCM}

\# multiplico numeroBajo*numeroAlto = numerado	\newline
mult	a0, a1\newline\newline
\# guardo en t0 el resultado de la multiplicacion anterior (numerador)
mflo	t0\newline\newline
\# guardo en el stack el numerador\newline	
sw		t0, 16(\$fp)\newline\newline
\# llamo a la funcion mcd con los parametros a0 y a1\newline			
jal 	mcd\newline

Sigue:\newline
\#guardo en el stack el valor de mcd, valor que retorno la funcion (es el denominador)\newline
sw		v0, 20(\$fp)\newline\newline			
\#recupero del stack el valor de numeroBajo*numeroAlto\newline
lw		t0, 16(\$fp)\newline\newline
\#Hago (numeroBajo*numeroAlto)/(mcd(numeroBajo,numeroAlto))\newline
div		t0,v0\newline
mflo	t1\newline\newline
\#Guardo en V1 el resultado de mcm	\newline			
move	v0,t1\newline\newline
\#Guardo en el stack el resultado de mcm	\newline		
sw		t1,24(\$fp)\newline

Aquí es importante destacar que antes de hacer el llamado a la función mcd, se guarda el valor de la variable local de la función (t0) en el stack frame de la función. Esto es porque la función mcd puede utilizar este registro y en consecuencia si modifica el valor, luego cuando retorne a la siguiente instrucción de mcm, obtendremos un error en el cálculo, dado que se perdió el valor original de la variable local.\newline

\section{Diagrama del Stack Frame}

\subsection{MCD}

\includegraphics[scale=0.8]{stackmcd}

\subsection{MCM}

\includegraphics[scale=0.8]{stackmcm}

\begin{figure}[!htp]
\begin{center}

\end{center}
\end{figure}

\section{Conclusiones}

Este trabajo práctico nos sirvió para ver cómo utilizar correctamente el stack de una función, respetando la convención de la ABI. También notamos que es necesario tener presente el esquema del stack de cada función dado que nos resultó muy importante a la hora de realizar el código de ambas funciones en MIPS 32.
Otro hito importante fue el uso de gdb, mediante el cual pudimos debuguear el programa para solucionar algunos inconvenientes presentados en las funciones hechas en MIPS 32. Con gdb pudimos ir corroborando los valores que iban tomando los registros al momento de ejecutar una instrucción, y de esta manera poder detectar la línea que teníamos que corregir si había algún valor que no era el esperado.

\null\newpage

\section{El código fuente, en lenguaje C:}
	
	\lstinputlisting[language=C]{../../common.c}
	\lstinputlisting[language=C]{../../commonfunc.h}
	\lstinputlisting[language=C]{../../commonfunc.c}
	\lstinputlisting[language=C]{../../mathfunc.h}	
	\lstinputlisting[language=C]{../../mathfunc.c}	

\null\newpage

\section{El código Assembler:}
\lstinputlisting[language={[x86masm]Assembler}, firstline=1, lastline=116, basicstyle=\small]{../../mathfunc.S}

\newpage

\includepdf[pages={1-}]{src/enunciado.pdf}

\newpage

\begin{thebibliography}{99}

\bibitem{euclides} Algoritmo de Euclides, https://es.wikipedia.org/wiki/Algoritmo\verb|_de_|Euclides
\bibitem{gdb} Documentación GDB, https://www.gnu.org/software/gdb/documentation
\bibitem{func} Llamadas a funciones, func\_call\_conv.pdf, Yahoo Groups - Orga-Comp
\bibitem{mips} Conjunto de instrucciones, MIPSQuickRef.pdf, Yahoo Groups - Orga-Comp


\end{thebibliography} 

\end{document}
